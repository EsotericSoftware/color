# Color

This Java library provides color space conversions and other color related utilities.

- **Color space conversions** 40+, bidirectional
- **Spectral locus** wavelength conversion, dominant wavelength, purity
- **Gamut management** for multiple display standards
- **RGBW/RGBWW mixing** for LED systems
- **Color difference** Delta E 2000, MacAdam steps, WCAG contrast
- **Color utilities** CCT/Duv, gamma, harmony, formatting, lerp
- **Industry standard color spaces** video, broadcasting, printing
- **Extensive tests** 110+

The code uses floats and is straightforward, without dependencies, making it easy to port if needed.

## Color Space Conversions

### RGB-Based Color Spaces

#### Standard Color Models
- RGB
- Linear RGB
- HSV (Hue, Saturation, Value)
- HSL (Hue, Saturation, Lightness)  
- HSI (Hue, Saturation, Intensity)
- IHS (Intensity, Hue, Saturation)

#### CIE Color Spaces
- Lab (CIELAB)
- Luv (CIELUV)
- LCh - Lab-based cylindrical
- LCHuv - Luv-based cylindrical
- uv (CIE 1960 UCS)
- u'v' (CIE 1976 UCS)
- XYZ (CIE 1931 XYZ)
- xy (CIE 1931 chromaticity)
- xyY (CIE 1931 xyY)

#### Perceptually Uniform Spaces
- Oklab - Modern perceptually uniform color space
- Oklch - Cylindrical version of Oklab
- Okhsv - Oklab-based HSV
- Okhsl - Oklab-based HSL
- HSLuv - Human-friendly perceptual HSL

#### Video & Broadcasting
- YCbCr - Digital video, supports ITU BT.601 and BT.709
- YUV - PAL television
- YIQ - NTSC television
- YCoCg - Lossless color transform
- YCC - Kodak Photo YCC
- YES - Xerox YES television

#### Printing & Other Spaces
- CMYK (Cyan, Magenta, Yellow, Key/Black) - Subtractive colors for printing
- LMS (Long, Medium, Short) - Human cone response
- TSL (Tint, Saturation, Lightness) - Face detection
- rg - Normalized chromaticity
- Hunter Lab - Precursor to CIELAB
- C1C2C3 (3 opponent color channels) - Image processing
- O1O2 (2 opponent color channels) - Image processing

#### Advanced Color Spaces
- CAM16 - Color appearance model with viewing conditions
- CAM16UCS - Uniform color space based on CAM16
- HCT (Hue, Chroma, Tone) - Google Material You
- ACES2065-1 - Academy Color Encoding System, AP0 primaries
- ACEScg - Working space for CGI, AP1 primaries
- ACEScc - Logarithmic for color grading, AP1 primaries
- ITP (ICtCp/ITU-R BT.2100) - HDR and wide color gamut

### Gradient Interpolation
This image shows a few gradients for some of the supported color spaces. Other color spaces aren't suitable for gradient visualization. It was generated by [Gradients.java](test/com/esotericsoftware/colors/Gradients.java).

![](images/gradients.png)

### Example Usage

Import the color space records:
```java
import com.esotericsoftware.color.space.*;
```

Records are provided for type safety and method signature clarity rather than using `float[]`. Any record can be converted using `float[] values = Util.floats(record)`.

This library breaks from Java naming conventions to use capitalization that matches the color space names, making the code clearer and more aligned with color science literature.

#### Standard Color Models
- **HSV** (Hue, Saturation, Value)
  ```java
  HSV hsv = rgb.HSV();
  RGB rgb = hsv.RGB();
  ```

- **HSL** (Hue, Saturation, Lightness)
  ```java
  HSL hsl = rgb.HSL();
  RGB rgb = hsl.RGB();
  ```

- **HSI** (Hue, Saturation, Intensity)
  ```java
  HSI hsi = rgb.HSI();
  RGB rgb = hsi.RGB();
  ```

#### CIE Color Spaces
- **Lab** (CIELAB)
  ```java
  Lab lab = rgb.Lab();
  RGB rgb = lab.RGB();
  // With white point:
  Lab lab = rgb.Lab(Illuminant.CIE2.D50);
  Lab lab = xyz.Lab(customWhitePoint);
  ```

- **Luv** (CIELUV)
  ```java
  Luv luv = rgb.Luv();
  RGB rgb = luv.RGB();
  ```

- **LCh** (Lab-based cylindrical)
  ```java
  LCh lch = rgb.LCh();
  RGB rgb = lch.RGB();
  ```

- **XYZ** (CIE 1931 XYZ)
  ```java
  XYZ xyz = rgb.XYZ();
  RGB rgb = xyz.RGB();
  ```

#### Perceptually Uniform Spaces
- **Oklab** - Modern perceptually uniform color space
  ```java
  Oklab oklab = rgb.Oklab();
  RGB rgb = oklab.RGB();
  ```

- **Oklch** - Cylindrical version of Oklab
  ```java
  Oklch oklch = rgb.Oklch();
  RGB rgb = oklch.RGB();
  ```

- **Okhsv/Okhsl** - Oklab-based HSV/HSL alternatives
  ```java
  Okhsv okhsv = rgb.Okhsv();
  Okhsl okhsl = rgb.Okhsl();
  RGB rgbFromOkhsv = okhsv.RGB();
  RGB rgbFromOkhsl = okhsl.RGB();
  ```

#### Video & Broadcasting

#### Printing & Other Spaces
- **CMYK** - Cyan, Magenta, Yellow, Key (Black)
  ```java
  CMYK cmyk = rgb.CMYK();
  RGB rgb = cmyk.RGB();
  ```

- **LMS** - Cone Response Space
  ```java
  LMS lms = xyz.LMS(LMS.CAT.Bradford);
  XYZ xyz = lms.XYZ(LMS.CAT.Bradford);
  ```

- **O1O2** - Opponent Color Space (Forward only)
  ```java
  O1O2 o1o2 = rgb.O1O2();
  // O1: Yellow-blue opponent [-1..1]
  // O2: Red-green opponent [-0.5..0.5]
  ```

- **C1C2C3** - 3-Channel Opponent Space (Forward only)
  ```java
  C1C2C3 c1c2c3 = rgb.C1C2C3();
  // C1, C2, C3: Achromatic channels [0..pi/2]
  ```

### Chromaticity Coordinates
- **xy** (CIE 1931), **uv** (CIE 1976), **uv1960** (CIE 1960)
  ```java
  xy chromaticity = rgb.xy();
  xy chromaticity = rgb.xy(gamut);
  uv1960 uv60 = chromaticity.uv1960();
  RGB rgb = chromaticity.RGB();  // Uses sRGB gamut
  RGB rgb = chromaticity.RGB(gamut);
  uv uv76 = rgb.uv();
  XYZ xyz = new xyY(chromaticity.x(), chromaticity.y(), 50).XYZ();  // Y=50
  ```

## Color Temperature & Lighting

### Correlated Color Temperature (CCT)
```java
import com.esotericsoftware.color.CCT;

// Create CCT object
CCT warmWhite = new CCT(2700);   // 2700K
CCT daylight = new CCT(6500);    // 6500K

// Convert to RGB
RGB warmRGB = warmWhite.RGB();          // On blackbody locus (Duv=0)
RGB daylightRGB = daylight.RGB(0.003f); // With Duv offset

// Calculate CCT from color
CCT cct = rgb.CCT();
float temperature = cct.K();

// Duv - Distance from Planckian locus
float duv = rgb.uv().Duv();
```

### RGB + White LEDs
```java
// RGBW (single white channel)
RGBW rgbw = rgb.RGBW(whitePoint);

// RGBWW (dual white channels)  
RGBWW rgbww = rgb.RGBWW(warmWhite, coolWhite);

// Create from color temperature (higher potential brightness)
CCT cct3000 = new CCT(3000);
RGBW rgbw = cct3000.RGBW(0.8f, whitePoint);  // 3000K at 80% brightness
RGBWW rgbww = cct3000.RGBWW(0.8f, warmWhite, coolWhite);
```

## Color Analysis & Utilities

### Color Difference
```java
// Delta E 2000 - Perceptual lightness, chromaticity, and hue difference
float deltaE = rgb1.deltaE2000(rgb2);
float deltaE = lab1.deltaE2000(lab2);

// With custom weights for L*, C*, H*
float deltaE = lab1.deltaE2000(lab2, 2f, 1f, 1f);

// MacAdam steps - Perceptual chromaticity difference
float steps = xy1.MacAdamSteps(xy2);

// CAM16-UCS distance (perceptually uniform)
float distance = cam16ucs1.deltaE(cam16ucs2);
```

### Accessibility & Contrast
```java
// WCAG contrast ratio (1:1 to 21:1)
float ratio = foreground.contrastRatio(background);

// Check WCAG compliance
boolean meetsAA = foreground.WCAG_AA(background, largeText);
boolean meetsAAA = foreground.WCAG_AAA(background, largeText);
```

### Color Analysis
```java
// Convert to grayscale (perceptual luminance)
float gray = rgb.grayscale();

// Check if color is achromatic
boolean isGray = rgb.achromatic();

// Get relative luminance
float luminance = rgb.luminance();
```

### Color Harmonies
```java
RGB baseColor = new RGB(1, 0.5, 0.25);
RGB complementary = baseColor.complementary();
RGB[] triadic = baseColor.triadic();
RGB[] analogous = baseColor.analogous(30f);  // 30° angle
RGB[] splitComp = baseColor.splitComplementary();
```

#### Video & Broadcasting Examples
- **YCbCr** - Digital video color space
  ```java
  YCbCr ycbcr = rgb.YCbCr(YCbCr.YCbCrColorSpace.ITU_BT_709_HDTV);
  RGB rgb = ycbcr.RGB(YCbCr.YCbCrColorSpace.ITU_BT_709_HDTV);
  ```

- **YUV/YIQ/YCoCg** - Television and lossless formats
  ```java
  YUV yuv = rgb.YUV();      // PAL television
  YIQ yiq = rgb.YIQ();      // NTSC television
  YCoCg ycocg = rgb.YCoCg(); // Lossless transform
  YCC ycc = rgb.YCC();      // Kodak Photo YCC
  YES yes = rgb.YES();      // Xerox YES
  ```

#### Advanced Color Spaces

- **TSL** (Tint, Saturation, Lightness) - Face Detection
  ```java
  TSL tsl = rgb.TSL();
  RGB rgb = tsl.RGB();
  // Optimized for skin tone analysis in computer vision
  // Note: When T=0, the inverse uses "negative zero" to distinguish between 
  // two possible solutions, as the reverse mapping is not unique
  ```

- **ITP** (ICtCp/HDR Color Space)
  ```java
  ITP itp = rgb.ITP();
  RGB rgb = itp.RGB();
  // Supports HDR content and wide color gamut (ITU-R BT.2100)
  // Full round-trip accuracy BT.2020 conversion
  ```

- **HCT** (Hue, Chroma, Tone) - Google Material You
  ```java
  HCT hct = rgb.HCT();
  RGB rgb = hct.RGB();
  // Perceptually accurate color system used in Material Design
  // Can also specify viewing conditions:
  HCT hct = rgb.HCT(CAM16.VC.sRGB);
  ```

- **CAM16** (Color Appearance Model)
  ```java
  // Using default viewing conditions
  CAM16 cam = rgb.CAM16();
  
  // With custom viewing conditions
  CAM16.VC vc = CAM16.VC.with(
    Illuminant.CIE2.D50,  // White point
    40,                   // Adapting luminance (cd/m²)
    50,                   // Background L* value
    2,                    // Surround (0=dark, 1=dim, 2=average)
    false                 // Discounting illuminant
  );
  CAM16 cam = rgb.CAM16(vc);
  
  // Convert to/from uniform color space
  CAM16UCS ucs = cam.CAM16UCS();
  CAM16 cam2 = ucs.CAM16(vc);
  RGB rgb = ucs.RGB(vc);
  ```

- **ACES** (Academy Color Encoding System)
  ```java
  // ACES2065-1 (archival format, AP0 primaries)
  ACES2065_1 aces2065 = rgb.ACES2065_1();
  RGB rgb = aces2065.RGB();
  
  // ACEScg (CGI working space, AP1 primaries)
  ACEScg acesCg = rgb.ACEScg();
  RGB rgb = acesCg.RGB();
  
  // ACEScc (logarithmic color grading, AP1 primaries)
  ACEScc acesCc = rgb.ACEScc();
  RGB rgb = acesCc.RGB();
  ```

## Gamut Management

The `Gamut` class manages color space boundaries:

### Predefined Gamuts
```java
Gamut srgb = Gamut.sRGB;          // Standard RGB
Gamut p3 = Gamut.DisplayP3;       // Display P3
Gamut rec2020 = Gamut.Rec2020;    // Rec. 2020
Gamut full = Gamut.all;           // Full visible spectrum
Gamut huaA = Gamut.PhilipsHue.A;  // Philips Hue A
var custom = new Gamut(red, green blue);
```

### Gamut Operations
```java
boolean inGamut = gamut.contains(chromaticity);

// Closest point if outside gamut
xy clamped = gamut.clamp(chromaticity);
```

## Utility Functions

### Component Access
CAM16UCS, Lab, LinearRGB, Luv, Oklab, RGB, XYZ:
```java
// Get component by index (0, 1, 2)
float value = lab.get(0);  // L component

// Set component by index (returns new instance)
Lab newLab = lab.set(1, 0.5f);  // Set a component

// Add value to all components
RGB lighter = rgb.add(0.1f);

// Add to specific component
RGB moreRed = rgb.add(0, 0.2f);

// Add different values to each component
Oklab shifted = oklab.add(0.1f, -0.05f, 0.02f);

// Subtract operations (same patterns as add)
XYZ darker = xyz.sub(10);
Lab lessGreen = lab.sub(1, 5);
```

Note: RGB values are clamped to [0..1], other spaces are not. Use LinearRGB or XYZ for interchange to preserve wide-gamut colors.

#### Scaling & Normalization
LinearRGB, RGB, XYZ:
```java
// Scale all components
RGB halfBright = rgb.scl(0.5f);

// Scale specific component
LinearRGB dimRed = linearRGB.scl(0, 0.7f);

// Scale each component differently
XYZ adjusted = xyz.scl(1.1f, 1.0f, 0.9f);

// Get min/max component
float darkest = rgb.min();
float brightest = rgb.max();

// Normalize (divide by max component)
LinearRGB normalized = linearRGB.nor();
```

#### Distance Calculations
CAM16UCS, Lab, LinearRGB, Luv, Oklab, RGB, uv, xy, XYZ:
```java
// Euclidean distance
float distance = color1.dst(color2);

// Squared distance (faster, no sqrt)
float distSquared = color1.dst2(color2);
```

### Gamma Correction
```java
import static com.esotericsoftware.color.Util.*;

// sRGB gamma encoding/decoding
float encoded = sRGB(linearValue);
float linear = linear(sRGBValue);

// Custom gamma
float encoded = gammaEncode(linear, 2.2f);
float decoded = gammaDecode(encoded, 2.2f);
```

### Float arrays
```java
import static com.esotericsoftware.color.Util.*;

// Convert any color record to float array
float[] rgbArray = floats(rgb);  // [r, g, b]
float[] hsvArray = floats(hsv);  // [H, S, V]
float[] labArray = floats(lab);  // [L, a, b]
```

### Output Formatting
```java
import static com.esotericsoftware.color.Util.*;

// Hex color string
String hex1 = hex(new RGB(0.5f, 0.5f, 0.5f));  // "808080"
String hex2 = hex(0.5f, 0.5f, 0.5f);           // "808080"

// RGB string (float values)
String str1 = toString(new RGB(0.5f, 0.5f, 0.5f));  // "0.5, 0.5, 0.5"
String str2 = toString(0.5f, 0.5f, 0.5f);           // "0.5, 0.5, 0.5"

// RGB string (0-255 values)
String str255_1 = toString255(new RGB(0.5f, 0.5f, 0.5f));  // "128, 128, 128"
String str255_2 = toString255(0.5f, 0.5f, 0.5f);           // "128, 128, 128"

// DMX control
int dmx8bit = dmx8(0.5f);    // 128
int dmx16bit = dmx16(0.5f);  // 32767
```

## Spectral Locus

Utilities are provided for working with spectral colors and the visible spectrum boundary.

![](images/uv.jpg)

### Wavelength to Chromaticity
```java
import com.esotericsoftware.color.SpectralLocus;

// Convert wavelength (380-700nm) to CIE u'v' coordinates
uv color550nm = SpectralLocus.uv(550);  // Green at 550nm
xy color550nmXY = SpectralLocus.xy(550);  // Same in xy space

// Get exact spectral colors
uv red = SpectralLocus.uv(700);    // Deep red
uv blue = SpectralLocus.uv(450);   // Blue
uv green = SpectralLocus.uv(550);  // Green
```

### Spectrum Boundary Testing
```java
// Check if a color is within the visible spectrum
uv testColor = rgb.uv();
boolean visible = SpectralLocus.contains(testColor);

// Colors outside the spectral locus are not physically realizable
boolean impossible = SpectralLocus.contains(new uv(0.8f, 0.8f)); // false
```

### Dominant Wavelength
```java
// Find the dominant wavelength of any color
uv color = new RGB(0, 1, 0).uv();  // Green RGB
float wavelength = SpectralLocus.dominantWavelength(color);  // ~550nm

// Purple/magenta colors return negative complementary wavelengths
uv magenta = new RGB(1, 0, 1).uv();
float purpleWave = SpectralLocus.dominantWavelength(magenta);  // Negative value

// Use custom white point
float wavelength2 = SpectralLocus.dominantWavelength(color, Illuminant.CIE2.A);
```

### Excitation Purity
```java
// Measure color saturation (0 = white, 1 = pure spectral color)
float purity = SpectralLocus.excitationPurity(color);

// Gray has low purity
uv gray = new RGB(0.5f, 0.5f, 0.5f).uv();
float grayPurity = SpectralLocus.excitationPurity(gray);  // < 0.1

// Saturated colors have high purity
uv saturated = new RGB(1, 0, 0).uv();
float redPurity = SpectralLocus.excitationPurity(saturated);  // > 0.8
```

## Standard Illuminants

CIE standard illuminants are included for both 2° and 10° observers:

```java
import com.esotericsoftware.color.Illuminant;

// 2° observer
XYZ d65_2deg = Illuminant.CIE2.D65;
XYZ d50_2deg = Illuminant.CIE2.D50;

// 10° observer
XYZ d65_10deg = Illuminant.CIE10.D65;
```

Available illuminants: A, C, D50, D55, D65, D75, F2, F7, F11

## Chromatic Adaptation Transforms

```java
// Various CAT methods for cone response
LMS lms = xyz.LMS(LMS.CAT.Bradford);
LMS lms = xyz.LMS(LMS.CAT.vonKries);
LMS lms = xyz.LMS(LMS.CAT.CAT02);
LMS lms = xyz.LMS(LMS.CAT.CAT97);
LMS lms = xyz.LMS(LMS.CAT.HPE);

// Convert back
XYZ xyz = lms.XYZ(LMS.CAT.Bradford);
```

## Usage Examples

### Basic Color Conversion
```java
// Convert RGB to HSV
RGB rgb = new RGB(0.5f, 0.7f, 0.3f);
HSV hsv = rgb.HSV();
System.out.println("Hue: " + hsv.H() + "°");
// Convert back to RGB
RGB rgb2 = hsv.RGB();
```

### Perceptual Colors
```java
// Use Oklab for perceptually uniform operations
Oklab color1 = rgb1.Oklab();
Oklab color2 = rgb2.Oklab();
// Interpolate in perceptual space
Oklab middle = color1.lerp(color2, 0.5f);
```

### Color Interpolation
```java
import static com.esotericsoftware.color.Util.*;

RGB red = new RGB(1, 0, 0);
RGB blue = new RGB(0, 0, 1);

// RGB interpolation (simple but not perceptual)
RGB rgbMix = red.lerp(blue, 0.5f);  // Purple

// Lab interpolation (perceptually uniform)
Lab labRed = red.Lab();
Lab labBlue = blue.Lab();
Lab labMix = labRed.lerp(labBlue, 0.5f);  // More perceptual purple

// HSL interpolation (hue-based, handles angles correctly)
HSL hslRed = red.HSL();
HSL hslBlue = blue.HSL();
HSL hslMix = hslRed.lerp(hslBlue, 0.5f);  // Hue wraparound, through magenta

// Oklab interpolation (modern perceptual)
Oklab oklabRed = red.Oklab();
Oklab oklabBlue = blue.Oklab();
Oklab oklabMix = oklabRed.lerp(oklabBlue, 0.5f);  // Best perceptual result

// Create smooth perceptual gradients
for (float t = 0; t <= 1; t += 0.1f) {
    Oklab interpolated = oklabRed.lerp(oklabBlue, t);
    RGB color = interpolated.RGB();
    // Use color for gradient.
}
```

### Color Temperature to RGB
```java
// Create warm white (2700K)
CCT warmCCT = new CCT(2700);
RGB warmWhite = warmCCT.RGB();

// Create daylight (6500K) with slight green tint
CCT daylightCCT = new CCT(6500);
RGB daylight = daylightCCT.RGB(-0.003f);  // With Duv offset
```

### Accessibility Checking
```java
RGB background = new RGB(1, 1, 1);  // White
RGB text = new RGB(0.2f, 0.2f, 0.2f);
float contrast = text.contrastRatio(background);
boolean accessible = text.WCAG_AA(background, false);
if (!accessible) System.out.println("Text color fails WCAG AA standards");
```
